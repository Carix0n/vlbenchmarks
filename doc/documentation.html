<!DOCTYPE group PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<group>

<h1> Documentation </h1>

<ul>
  <li><a href="%pathto:doc.structure;">Framework structure</a>
  <ul>
    <li><a href="%pathto:doc.extractors;">Image feature extractors</a></li>
    <li><a href="%pathto:doc.datasets;">Datasets</a></li>
    <li><a href="%pathto:doc.datasets;">Benchmarks</a></li>
  </ul>
  </li>
  <li><a href="%pathto:doc.parallel;">Parallelisation</a></li>
  <li><a href="%pathto:doc.caching;">Caching</a></li>
  <li><a href="%pathto:doc.logging;">Logging</a></li>
</ul>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="doc.structure">Framework structure</h2>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
<b>doc</b> is is organised into four parts, corresponding to
an equal number of MATLAB packages (namespaces):</p>

<ul>

<li><a href="%pathto:doc.extractors;">Image feature extractors</a>
(<strong><code>localFeatures</code></strong>). This package contains
wrapper for features detectors and descriptors. Add your own wrapper
here to evaluate your features.</li>

<li><a href="%pathto:doc.datasets;">Datasets</a>
(<strong><code>datasets</code></strong>) This package contains code
that manages (downloads and reads) benchmark data. The most common use
is to adopt one of the supported standard benchmarks, but you may want
to add a wrapper to your own dataset here.</li>

<li><a href="%pathto:doc.benchmarks;">Feature benchmarks.</a>
(<strong><code>benchmarks</code></strong>). This package contains the
benchmarking code.</li>

<li>Supporting functions and classes
(<strong><code>helpers</code></strong>). </li>
</ul>

<p>All classes and functions in this project which supports some optional 
  parameters accept those in a similar manner as Matlab functions:</p>
<precode type="matlab">
  function(obligatoryParams,'OptionName',OptionValue,...)
</precode>
<p>Available options are listed in the help string of the function or class. 
For classes, options are set in their constructor.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="doc.extractors">Feature objects</h3>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>All classes located in the package <code>localFeatures</code> are subclasses 
of <code>lGenericLocalFeaturesExtractor</code>. The included image feature
detectors are summarised in the following table:</p>

<table border="1" width="600px">
    <tr>
        <th rowspan="2">Class name</th>
        <th colspan="2" class="center">Extracts</th>
        <th colspan="3" class="center">Supported platforms</th>
        <th rowspan="2" class="center">Note</th>
    </tr>
    <tr>
        <th class="center">Feat.</th>
        <th class="center">Descr.</th>
        <th class="center">WIN</th>
        <th class="center">LNX</th>
        <th class="center">OS X</th>
    </tr>
    <tr>
        <td>VlFeatSift</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td>Built-in <a href="#doc.ref1">[1]</a>, DoG detector, SIFT descriptor</td>
    </tr>
    <tr>
        <td>VlFeatCovdet</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td>Built-in, DoG, Hessian and Harris detectors and their variants.</td>
    </tr>
    <tr>
        <td>VlFeatMser</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td class="center">Y</td>
        <td>Built-in <a href="#doc.ref1">[1]</a></td>
    </tr>
    <tr>
        <td>VggAffine</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td>Affine feature frame detection<a href="#doc.ref2">[2]</a></td>
    </tr>
    <tr>
        <td>VggDescriptor</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td>Descriptor calculation from <a href="#doc.ref2">[2]</a></td>
    </tr>
    <tr>
        <td>Ebr</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td>Edge based region detector <a href="#doc.ref2">[2]</a></td>
    </tr>
    <tr>
        <td>Ibr</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td>Intensity based region detector <a href="#doc.ref2">[2]</a></td>
    </tr>
    <tr>
        <td>CmpBinHessian</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td class="center">N</td>
        <td class="center">Y</td>
        <td class="center">N</td>
        <td>Hessian affine <a href="#doc.ref3">[3]</a></td>
    </tr>
</table>


<h4 id="doc.benchmarkowndet">Benchmarking your own feature extractor</h4>

<p> This framework is easily extensible with your own image feature extraction
algorithm as only two methods has to be implemented. To start you need to
inherit from the <code>GenericLocalFeaturesExtractor</code> and
implement methods <code>extractFeatures(imgPath)</code> and
<code>extractDescriptors(imgPath, frames)</code>. </p>

<p>You can also use the existing infrastructure of the benchmarking suite.
For example, by inheriting from <code>GenericLocalFeatureExtractor</code>
you also inherit from the <code>helpers.Logger</code> class which implements
simple logger. See <a href="%pathto:doc.logging;">Logging</a> for details.</p>

<p>Another helper class used with the most of the built in detectors is 
<code>helpers.GenericInstaller</code>. This class handles installation process
and supports to define class dependencies on web-located archives, mex files
and other classes.</p>

<p>In the following example you can see more extensive feature extractor which
supports both feature frame detection and descriptor calculation. Also this
class, when constructed, downloads and compile the source code of the
detector.</p>

<precode type="matlab">
classdef ExtractorY &lt; localFeatures.GenericLocalFeatureExtractor &amp; ...
  helpers.GenericInstaller
% localFeatures.DetectorY Y feature frames detector.

%   localFeatures.DetectorY('OptionName', optionValue) Construct new wrapper
%   of Y image features extractor. This algorithm is able to both detect image
%   features and compute their descriptors.
%
%   This class support caching and automatic installation. The sources are
%   downloaded from:
%
%   http://supercoolstuff.com/dreamdetector.zip
%
% Options:
%   DetOption:: 0
%     Serious configuration stuff...
%
%   AutoInstall:: true
%     Install dependencies during object construction.
%
%   This class accepts helpers.Logger options.
%
% See also: localFeatures.DetectorX helpers.Logger
  properties (SetAccess=private, GetAccess=public)
    Opts = struct('detOption',0); % Default option value
  end
  properties (Constant)
    % Location of your code
    Dir = fullfile('data','software','exy');
    % URL with the source codes
    Url = 'http://supercoolstuff.com/dreamdetector.zip';
    % MEX files needed to be compiled for the detector
    SrcFiles = {fullfile(localFeatures.ExtractorY.Dir,'y_algorithm.c')};
    % MEX files needed to be compiled for the detector
    MexFiles = ...
      {fullfile(localFeatures.ExtractorY.Dir,['y_algorithm.',mexext])};
  end
  methods
    function obj = ExampleLocalFeatureExtractor(varargin)
      obj.Name = 'Detector Y'; % Name of the wrapper
      varargin = obj.configureLogger(obj.Name,varargin); % Configure logger
      varargin = obj.checkInstall(varargin); % Check whether installed
      obj.Opts = vl_argparse(obj.Opts,varargin); % Parse object options
      obj.setup(); % Setup the paths
    end

    function setup(obj)
      % setup Setup extractorY paths.
      addpath(obj.Dir);
    end
    
    function [frames descriptors] = extractFeatures(obj, imagePath)
      % extractFeatures Extract features from an image
      %   FRAMES = extractFeatures(IMG_PATH) Detect features in image IMG_PATH
      %   using the Y algorithm.
      %
      %   [FRAMES DESCRIPTORS] = extractFeatures(IMG_PATH) Detect frames and
      %   compute their descriptors using the Y algorithm.
      frames = obj.loadFeatures(imagePath,nargout > 1); % Check cache
      if numel(frames) > 0; return; end;
      descriptors = [];
      obj.info('Computing frames of image %s.',getFileName(imagePath));
      if nargout == 1
        frames = y_algorithm(imagePath, obj.Opts{:});
        obj.debug('Frames computed in %gs',toc(startTime));
      elseif nargout == 2
        [frames descriptors] = y_algorithm(imagePath, obj.Opts{:});
        obj.debug('Frames and descriptors computed in %gs',toc(startTime));
      end
      obj.storeFeatures(imagePath, frames, descriptors); % Cache the results
    end

    function [frames descriptors] = extractDescriptors(obj, imagePath, frames)
      % extractDescriptors Extract descriptors of given frames
      startTime = tic;
      obj.info('Computing descriptors of image %s.',getFileName(imagePath));
      [frames, descriptors] = y_algorithm(imagePath,frames,obj.Opts{:});
      obj.debug('Descriptors computed in %gs',toc(startTime));
    end

    function signature = getSignature(obj)
      signature = [helpers.struct2str(obj.Opts),';',...
        helpers.fileSignature(obj.MexFiles)]; % Detector unique signature
    end
  end
  methods (Access=protected)
    % Define which archives should be downloaded and where extracted
    function [urls dstPaths] = getTarballsList(obj)
      import localFeatures.*;
      urls = {DetectorY.Url};
      dstPaths = {DetectorY.Dir};
    end
    % Define which mex files should be compiled
    function [srclist flags] = getMexSources(obj)
      import helpers.*;
      srclist = obj.SrcFiles;
      % Flags passed to mex command
      flags = {};
    end
  end
end
</precode>


<p>
Method <code>extractFeatures(imgPath)</code> can be called with one
output argument when only feature frames need to be detected. When
called with two output arguments, it extracts feature frames
descriptors as well. This may seem to be dual to
the <code>extractDescriptors()</code> method however some detectors
does not support computation of descriptors of given frames.
</p>

<p>
If you want to take advantage of caching, you can use <code>loadFeatures()</code>
or <code>obj.storeFeatures()</code> methods which implements access to the
cache. However with that you will need to implement
method <code>obj.getSignature()</code> which generates unique string
signature of the detector properties. Caching can be enabled/disable with
methods <code>obj.enableCaching()</code>, <code>obj.disableCaching()</code>
</p>
 
<p>
To see details about the logging, class options and installation
framework, see
the <code>localFeatures.ExampleLocalFeatureExtractor</code> class
which implements simple feature detector together with simple descriptor.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="doc.datasets">Datasets</h3>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>All datasets are subclasses of abstract <code>GenericDataset</code> which defines
method <code type="matlab">getImagePath(imageNumber)</code>, method for accessing
images. Number of images in the dataset can be obtained through object property
<code type="matlab">obj.NumImages</code>.</p>

<p>Another abstract class is <code>GenericTransfDataset</code> which adds
another abstract method <code type="matlab">getTransformation(imageNumber)</code>
which returns homography between dataset images and a reference image (first image).</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h4 id="doc.datasets">VggAffineDataset</h4>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>Dataset which is a direct subclass of <code>GenericTransfDataset</code> is
<code>VggAffineDataset</code>. This code handles the datasets presented in 
<a href="#doc.ref2">[2]</a> and is used mainly for the repeatability 
benchmarks. Datasets are available at 
<a href="http://www.robots.ox.ac.uk/~vgg/research/affine/">VGG website</a>.</p>

<p>Available categories (accessible through option <code>'Category'</code>) are:</p>

<table border="1" width="400px">
    <tr>
        <th class="center">Category Name</th>
        <th class="center">'Category' option value</th>
        <th class="center">Image transformation</th>
    </tr>
    <tr>
        <td class="center">Wall</td>
        <td class="center"><code>'wall'</code></td>
        <td class="center">Viewpoint angle</td>
    </tr>
    <tr>
        <td class="center">Boat</td>
        <td class="center"><code>'boat'</code></td>
        <td class="center">Scale changes</td>
    </tr>
    <tr>
        <td class="center">Bark</td>
        <td class="center"><code>'bark'</code></td>
        <td class="center">Scale changes</td>
    </tr>
    <tr>
        <td class="center">Bikes</td>
        <td class="center"><code>'bikes'</code></td>
        <td class="center">Increasing blur</td>
    </tr>
    <tr>
        <td class="center">Trees</td>
        <td class="center"><code>'trees'</code></td>
        <td class="center">Increasing blur</td>
    </tr>
    <tr>
        <td class="center">Leuven</td>
        <td class="center"><code>'leuven'</code></td>
        <td class="center">Decreasing light</td>
    </tr>
    <tr>
        <td class="center">UBC</td>
        <td class="center"><code>'ubc'</code></td>
        <td class="center">JPEG compression</td>
    </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h4 id="doc.datasets">VggRetrievalDataset</h4>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>For the retrieval benchmark <code>VggRetrievalDataset</code> wraps around 
datasets introduced in <a href="#doc.ref4">[4]</a>, <a href="#doc.ref5">[5]</a>
These datasets provide both a set of images and a set of queries. Each query
consist from the query image and a query bounding box inside it and
three subset of images:</p>

<ul>
  <li><strong>Good</strong> A nice, clear picture of the object/building</li>
  <li><strong>Ok</strong> More than 25% of the object is clearly visible.</li>
  <li><strong>Junk</strong> Less than 25% of the object is visible, or there are very high 
    levels of occlusion or distortion.</li>
  <li><strong>Bad</strong> Object not present.</li>
</ul>

<p>Each query is available through method <code>getQuery(queryNum)</code> which 
returns query structure with the following format:</p>

<precode type='matlab'>
>> dst = datasets.VggRetrievalDataset();
(INFO)  VggRetrievalDataset:  Loading dataset VggRetrievalDataset.
(DEBUG) VggRetrievalDataset:  Size of the images subset: 945
>> dst.getQuery(1)

ans = 

         name: 'all_souls_1'        % Query name
    imageName: 'all_souls_000013'   % Name of the query image
      imageId: 8                    % Query image id
          box: [4x1 double]         % Query bounding box [xmin ymin xmax ymax]
         good: [1x24 double]
           ok: [1x54 double]
         junk: [1x33 double]
</precode>

<p>Number of images in the dataset can be obtained through object property
<code type="matlab">obj.NumQueries</code>.</p>

<p>Currently, two dataset categories are available:</p>

<table border="1" width="500px">
    <tr>
        <th class="center">Category Name</th>
        <th class="center">'Category' option value</th>
        <th class="center">Number of images</th>
        <th class="center">Number of queries</th>
        <th class="center">Source</th>
    </tr>
    <tr>
        <td>The Oxford Buildings Dataset <a href="#doc.ref4">[4]</a></td>
        <td class="center"><code>'oxbuild'</code></td>
        <td class="center">5062</td>
        <td class="center">55</td>
        <td><a href="http://www.robots.ox.ac.uk/~vgg/data/oxbuildings/">link</a></td>
    </tr>
    <tr>
        <td>The Paris Dataset<a href="#doc.ref5">[5]</a></td>
        <td class="center"><code>'paris'</code></td>
        <td class="center">6412</td>
        <td class="center">55</td>
        <td><a href="http://www.robots.ox.ac.uk/~vgg/data/parisbuildings/">link</a></td>
    </tr>
</table>

<p>As the dataset contains thousands of images, it is possible to use only
a subset of images by specifying sizes of the dataset subsets with the following 
options:</p>

<precode>
    GoodImagesNum :: inf
      Number of 'Good' images preserved in the databse. When inf, all
      images preserved.
 
    OkImagesNum :: inf
      Number of 'ok' images preserved in the databse. When inf, all
      images preserved.
 
    JunkImagesNum :: inf
      Number of 'junk' images preserved in the databse. When inf, all
      images preserved.
 
    BadImagesNum :: 100
      Number of 'junk' images preserved in the databse. When inf, all
      images preserved.
 
    SamplingSeed :: 1
      Seed of the random number generator used for sampling the image
      dataset.
</precode>

<p>Subsets are sampled used uniform random sampling and changing the seed 
of random number generator more sampling of the same size can be generated.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="doc.benchmarks">Benchmarks</h3>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>All benchmark classes are subclasses of abstract class 
<code>GenericBenchmark</code>. 
Currently in the project, three benchmarks are available.</p>

<p><code>RepeatabilityBenchmark</code> is based on tests introduced in 
<a href="#doc.ref2">[2]</a>. For details about this test see the 
help string of the <code>RetrievalBenchmark</code> class or 
<a href="%pathto:tut.repeatability;">repeatability tutorial</a>.
Because this test is mostly reimplemented original test, wrapper of the
original benchmark <code>IjcvOriginalBenchmark</code> is also available.
</p>

<p><code>RetrievalBenchmark</code> class implements simple retrieval 
benchmark of image features detectors. For details see help string
of the class or 
<a href="%pathto:tut.retrieval;">retrieval tutorial</a>.
</p>

<p>In the current implementation, retrieval benchmark depends on the
<a href="https://gforge.inria.fr/projects/yael">Yael</a> library and 
unfortunately this library is not available for Microsoft Windows 
platforms.</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="doc.parallel">Parallelisation</h2>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>The parallelisation approach differs for the repeatability and retrieval 
benchmark but both of them is possible to run in parallel using the 
Parallel Computing Toolbox. For details, see its 
<a href="http://www.mathworks.com/help/distcomp/index.html">documentation</a>.
</p>

<p> In the case of repeatability benchmark, parallelisation is 
defined by user and can be run either over various detectors or over
images of the dataset by simply replacing <code>for</code> with
<code>parfor</code>, e.g.:</p>

<precode type="matlab">
for di = 1:numDetectors
  % Extract features from the first image to avoid race condition
  % as several processes may then try to write the same file.
  % Features does not have to be stored in any variable as they
  % cached.
  detectors{di}.extractFeatures(dataset.getImagePath(1));
  % Prevent cache to clear the last recently used items
  helpers.DataCache.disableAutoclear();
  parfor imageIdx = 2:numImages
    % Run the repeatability benchmark
  end
  helpers.DataCache.enableAutoclear();
end
</precode>

<p>This is possible thanks to the fact that the cache system depends only on the 
file system context and does not share any variables and generally, if the 
loops are properly designed, each process works with different data.
However cache autoclear has to be disabled as it can yield situations when 
two processes are deleting the same files or deleting files which are being
read by a different process.
</p>

<p>In the case of retrieval benchmark, the parallelisation is more complicated
task so the class <code>RetrievalBenchmark</code> already has several
parfor loops. Both features extraction and KNN search are run in parallel.</p>

<p>In the case of KNN search you can advantage both from symmetric processing 
and distributed computing as the Yael KNN uses OpenMP to run its algorithms
in several threads.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="doc.caching">Caching</h2>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<p>This project extensively caches its results in key-value pairs. String
key is usually created based on the properties of input data and processing
algorithm. Data are stored as <code>*.mat</code> files in directory
<code>./data/cache</code> where the mat file filename is created as MD5 sum
of the string key.</p>

<p>Input data are usually distinguished by a file signature which is made from
the file name and last modification date of the file. This is also used 
for algorithm binaries. Then the signature usually contain parameters
of the algorithm as their change usually yield different results.</p>

<h3 id="doc.caching.methods">DataCache methods</h3>

<p>Caching is implemented in class <code>helpers.DataCache</code>. Because
it is class only with static methods (in order to make it usable with parfor
loops). This class implements the following methods:</p>

<ul>
<li><code>data = DataCache.getData(key)</code> Get data from the cache 
  indexed by string key. If the data has not been found, returns [].</li>
                        
<li><code>storeData(data,key)</code> Store data identified by key.</li>
<li><code>res = hasData(key)</code> Check whether data are cached.</li>


<li><code>removeData(key)</code> Remove particular data from the cache.</li>

<li><code>clearCache()</code> Delete the last recently used data to limit 
  the overall cached data size to <code>DataCache.maxDataSize</code> limit.
</li>

<li><code>deleteAllCachedData()</code> Delete all cached data.</li>

<li><code>disableAutoClear()</code> Temporarily disable the autoclear 
  function. Cannot be called in parallel function as it creates a lock file.
</li>

<li><code>enableAutoClear()</code>Enable autoClear after disableAutoClear. 
  Cannot be called in parallel function as it deletes a lock file.</li>
</ul>

<h3 id="doc.caching.properties">DataCache properties</h3>

<p>The caching properties can be changed only in <code>DataCache.m</code> 
source code by changing the class constant properties which are:</p>

<ul>
<li><code>maxDataSize</code> Maximal storage space occupied by the 
  cached data in Bytes.</li>
<li><code>dataPath</code> Directory where to store cached data</li>
<li><code>dataFileVersion</code> Version of the .mat file used for data 
  storage</li>
<li><code>autoClear</code> Check whether storage size has not exceeded 
  the allowed size after each storeData call when true. If so, the oldest 
  data are removed</li>
<li><code>disable</code> Globally disable caching.</li>
</ul>

<p>Please note that the standard Matlab behaviour is to set these values only
when the class is used for the first time. Therefore to apply the options
you must call:</p>

<precode type="matlab">
>> clear all;
</precode>


<h4 id="doc.caching.autoclear">Auto clear functionality</h4>

<p>Caching system also implements a way how to limit the overall size of the
cached data, further denoted as an <i>autoclear</i> function. This basically
checks the size of the cached data and deletes the last recently used
items (based on the file modification date) to limit the storage usage.
Autoclear can be disabled globally by editing changing the class property
<code>helpers.DataCache.autoClear</code> or temporarily creating a lock
file by calling method <code>helpers.DataCache.disableAutoclear()</code>.
It is recommended to call this method before running parallel code to prevent
two processes to delete the same files.</p>

<h4 id="doc.caching.disabling">Disable caching</h4>

<p>Cache can be disabled globally by setting the constant property
<code>helpers.DataCache.autoClear</code> to true. Also several framework
classes implements methods <code>disableCaching()</code> and 
<code>enableCaching()</code> to control the caching behaviour of a single
class.</p>

<p>Cache does not support invalidation of data of a certain class. However
if you want to, for example invalidate cached data of a certain detector
you can use a simple trick to change the detector binary modification date:</p>

<precode type="matlab">
>> helpers.touch('./data/software/det_binary');
</precode>

<h3 id="doc.caching.limits">DataCache limits</h3>
<p>As the cache depends heavily on a file system it is basically limited by a 
number of files in a single directory. Having more files in a directory
than is the OS limit can lead to slower file operations in this directory.
Also using the cache with distributed computing may burden your network 
file system.</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="doc.logging">Logging</h2>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<p>Several classes in the framework uses the logging feature implemented
in <code>helper.Logger</code> class. This class supports to display
the events to std output or write them to a log file. It supports the 
following events, inspired by the apache Log4j framework:</p>

<table border="1" width="500px">
    <tr>
        <th class="center">Event name</th>
        <th class="center">'VerboseLevel' value</th>
        <th class="center">Usage</th>
    </tr>
    <tr>
        <td class="center">TRACE</td>
        <td class="center"><code>3</code></td>
        <td> finer-grained informational events than the DEBUG.</td>
    </tr>
    <tr>
        <td class="center">DEBUG</td>
        <td class="center"><code>2</code></td>
        <td>Information useful for debugging.</td>
    </tr>
    <tr>
        <td class="center">INFO</td>
        <td class="center"><code>1</code></td>
        <td>Informational messages about the application progress.</td>
    </tr>
    <tr>
        <td class="center">WARN</td>
        <td class="center"><code>0</code></td>
        <td>Logs potentially harmful situations. Calls 
          <code>warn</code> command to show the backtrace.</td>
    </tr>
    <tr>
        <td>ERROR</td>
        <td class="center"><code>-1</code></td>
        <td>Several errors which does not allow application
          to continue. Calls Matlab <code>error</code> function.</td>
    </tr>
</table>

<p>Verbose level which events should be logged can be set both globally editing
the file <code>helpers.Logger.m</code> and changing the default properties
values or locally for each object which inherits the <code>Logger</code> 
class by providing the <code>'OptionName',OptionValue</code> parameters
to the class constructor call. Supported options are:</p>

<precode>
   VerboseLevel:: [helpers.Logger.DEBUG]
    Maximal verbosity level of messages sent to stdout. If set to OFF all
    messages are ignored, even errors would not stop the program execution.

  FileVerboseLevel:: [helpers.Logger.OFF]
    Maximal verbosity level of messages which are written to a log file.

  LogFile :: [./data/log]
     Path to a log file.
</precode>

<p>If you want to change the format of the log output, just adjust the methods
<code type="matlab">helpers.Logger.displayLog</code> and 
<code type="matlab">helpers.Logger.logToFile</code> according to your 
aesthetic preferences.</p>

<h2 id="doc.logging.using">Logging to a file during distributed computation</h2>

<p>When your computation are being computed with several processes, possibly 
on several computers having a single logging file may lead to inconsistent
data. That is why we would like to create separate files for each Matlab
process.</p>

<p>In this case we cane use simple fact that Matlab creates default values for
object properties only once when the class is constructed for the first time.
And as in classic matlabpool each lab has got its own matlab process,
the log file name in the <code>helpers.Logger</code> can be set for 
example to:</p>

<precode type="matlab">
LogFile = fullfile('data',['log-',helpers.hostname(),...
  randsample(char(97:122),5)]);
</precode>

<p>And we can simply test it:</p>

<precode type="matlab">
>> matlabpool 5;
>> import helpers.Logger;
>> parfor i=1:3
  for j=1:3
    obj = testLogger();
    fprintf('Proc. #%d Obj. #%d: %s\n',i,j,obj.LogFile);
  end;
end;

Proc. #1 Obj. #1: data/log-comp02xcdqv
Proc. #1 Obj. #2: data/log-comp02xcdqv
Proc. #1 Obj. #3: data/log-comp02xcdqv
Proc. #2 Obj. #1: data/log-comp02lwmxr
Proc. #3 Obj. #1: data/log-comp02scirh
Proc. #3 Obj. #2: data/log-comp02scirh
Proc. #2 Obj. #2: data/log-comp02lwmxr
Proc. #2 Obj. #3: data/log-comp02lwmxr
Proc. #3 Obj. #3: data/log-comp02scirh
</precode>

<p>You can see that each process generated the random string only once.
If the parfor wold be distributed on more computers, the 
<code>hostname()</code> value would change as well.</p>

<h2 id="doc.logging.using">Using Logger in your own classes</h2>

<p>You can also use logger on your class as well simply by specifying the 
<code>helpers.Logger</code> as a superclass. Here is a simple template how
to do it and how to properly configure the logger:</p>

<precode type="matlab">
  classdef MyClass &lt; helpers.Logger
    methods
      function obj = RepeatabilityBenchmark(varargin)
        varargin = obj.configureLogger('MyClassName',varargin);
        % Now you can process varargin for your arguments
        obj.info('Constructed.');
      end
    end
  end
</precode>

<p>And constructing your object you will get:</p>

<precode type="matlab">
>> MyClass();
(INFO)  MyClassName:  Constructed.
</precode>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="vlbenchmarks.refs">References</h2>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

 <ol>
  <li id="vlbenchmarks.ref1">A. Vedaldi and B. Fulkerson. 
  <strong>VLFeat:</strong> An Open and Portable Library
  of Computer Vision Algorithms, 
  <a href="http://www.vlfeat.org/">vlfeat.org</a>, 2008.
  </li>
  <li id="vlbenchmarks.ref2"> K. Mikolajczyk, T. Tuytelaars,
  C. Schmid, A. Zisserman, J. Matas, F. Schaffalitzky, T. Kadir, and
  L. Van Gool. A comparison of affine region detectors. IJCV,
  1(65):43–72, 2005.</li>
  <li id="vlbenchmarks.ref3">Perdoch, M. and Chum, O. and Matas, J. 
  Efficient Representation of Local Geometry for Large Scale Object 
  Retrieval. In proceedings of CVPR09, 2009.
  </li>
  <li id="vlbenchmarks.ref4">J. Philbin, O. Chum, M. Isard, J. Sivic and 
  A. Zisserman. Object retrieval with large vocabularies and fast spatial 
  matching CVPR, 2007</li> 
  <li id="vlbenchmarks.ref5">J. Philbin, O. Chum, M. Isard, J. Sivic and 
  A. Zisserman., Lost in Quantization: Improving Particular Object Retrieval 
  in Large Scale Image Databases (2008)</li>
 </ol>
</group>
